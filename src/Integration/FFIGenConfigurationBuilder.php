<?php

declare(strict_types=1);

namespace Yangweijie\CWrapper\Integration;

use Yangweijie\CWrapper\Config\ConfigInterface;
use Yangweijie\CWrapper\Exception\ConfigurationException;

/**
 * Builds klitsche/ffigen YAML configuration from ProjectConfig
 */
class FFIGenConfigurationBuilder
{
    /**
     * Build klitsche/ffigen configuration array from ProjectConfig
     *
     * @param ConfigInterface $config Project configuration
     * @return array<string, mixed> FFIGen configuration array
     * @throws ConfigurationException If configuration is invalid
     */
    public function buildConfiguration(ConfigInterface $config): array
    {
        $this->validateConfiguration($config);

        $ffiGenConfig = [
            'headerFiles' => $this->buildHeadersConfiguration($config),
            'libraryFile' => $this->buildLibraryConfiguration($config),
            'outputPath' => $this->buildOutputConfiguration($config),
            'namespace' => $this->buildNamespaceConfiguration($config),
        ];

        // Add exclude patterns if provided
        $excludePatterns = $config->getExcludePatterns();
        if (!empty($excludePatterns)) {
            $ffiGenConfig['excludeConstants'] = $excludePatterns;
            $ffiGenConfig['excludeMethods'] = $excludePatterns;
        }

        return $ffiGenConfig;
    }

    /**
     * Generate YAML configuration string for klitsche/ffigen
     *
     * @param ConfigInterface $config Project configuration
     * @return string YAML configuration string
     * @throws ConfigurationException If configuration is invalid
     */
    public function buildYamlConfiguration(ConfigInterface $config): string
    {
        $configArray = $this->buildConfiguration($config);
        
        // Convert array to YAML format manually to match klitsche/ffigen format
        $yaml = "# FFIGen Configuration\n";
        $yaml .= "# Generated by C-to-PHP FFI Converter\n\n";
        
        $yaml .= "headerFiles:\n";
        foreach ($configArray['headerFiles'] as $header) {
            $yaml .= "  - " . $header . "\n";
        }
        
        $yaml .= "libraryFile: " . $configArray['libraryFile'] . "\n";
        $yaml .= "outputPath: " . $configArray['outputPath'] . "\n";
        $yaml .= "namespace: " . $configArray['namespace'] . "\n";
        
        if (isset($configArray['excludeConstants']) && !empty($configArray['excludeConstants'])) {
            $yaml .= "excludeConstants:\n";
            foreach ($configArray['excludeConstants'] as $pattern) {
                $yaml .= "  - " . $pattern . "\n";
            }
        }
        
        if (isset($configArray['excludeMethods']) && !empty($configArray['excludeMethods'])) {
            $yaml .= "excludeMethods:\n";
            foreach ($configArray['excludeMethods'] as $pattern) {
                $yaml .= "  - " . $pattern . "\n";
            }
        }
        
        return $yaml;
    }

    /**
     * Write FFIGen configuration to a temporary file
     *
     * @param ConfigInterface $config Project configuration
     * @return string Path to the temporary configuration file
     * @throws ConfigurationException If file cannot be written
     */
    public function writeTemporaryConfigFile(ConfigInterface $config): string
    {
        $yaml = $this->buildYamlConfiguration($config);
        
        $tempFile = tempnam(sys_get_temp_dir(), 'ffigen_config_');
        if ($tempFile === false) {
            throw new ConfigurationException('Cannot create temporary configuration file');
        }
        
        $tempFile .= '.yml';
        
        if (file_put_contents($tempFile, $yaml) === false) {
            throw new ConfigurationException('Cannot write to temporary configuration file: ' . $tempFile);
        }
        
        return $tempFile;
    }

    /**
     * Validate the project configuration for FFIGen compatibility
     *
     * @param ConfigInterface $config Project configuration
     * @throws ConfigurationException If configuration is invalid
     */
    private function validateConfiguration(ConfigInterface $config): void
    {
        if (empty($config->getHeaderFiles())) {
            throw new ConfigurationException('At least one header file must be specified');
        }

        foreach ($config->getHeaderFiles() as $headerFile) {
            if (!is_string($headerFile) || empty(trim($headerFile))) {
                throw new ConfigurationException('Header file paths must be non-empty strings');
            }
        }

        if (empty(trim($config->getLibraryFile()))) {
            throw new ConfigurationException('Library file must be specified');
        }

        if (empty(trim($config->getOutputPath()))) {
            throw new ConfigurationException('Output path must be specified');
        }

        if (empty(trim($config->getNamespace()))) {
            throw new ConfigurationException('Namespace must be specified');
        }
    }

    /**
     * Build headers configuration section
     *
     * @param ConfigInterface $config Project configuration
     * @return array<string> Header file paths
     */
    private function buildHeadersConfiguration(ConfigInterface $config): array
    {
        return array_map(function ($path) {
            // Use realpath if file exists, otherwise use original path
            return file_exists($path) ? realpath($path) : $path;
        }, $config->getHeaderFiles());
    }

    /**
     * Build library configuration section
     *
     * @param ConfigInterface $config Project configuration
     * @return string Library file path
     */
    private function buildLibraryConfiguration(ConfigInterface $config): string
    {
        $libraryFile = $config->getLibraryFile();
        
        // Use realpath if file exists, otherwise use original path
        $resolvedPath = file_exists($libraryFile) ? realpath($libraryFile) : $libraryFile;
        
        return $resolvedPath ?: $libraryFile;
    }

    /**
     * Build output configuration section
     *
     * @param ConfigInterface $config Project configuration
     * @return string Output path
     */
    private function buildOutputConfiguration(ConfigInterface $config): string
    {
        $outputPath = rtrim($config->getOutputPath(), '/\\');
        
        // Convert to absolute path if it's relative
        if (!$this->isAbsolutePath($outputPath)) {
            $outputPath = realpath('.') . DIRECTORY_SEPARATOR . $outputPath;
        }
        
        return $outputPath;
    }

    /**
     * Check if a path is absolute
     */
    private function isAbsolutePath(string $path): bool
    {
        return $path[0] === '/' || (PHP_OS_FAMILY === 'Windows' && preg_match('/^[A-Z]:\\\\/', $path));
    }

    /**
     * Build namespace configuration
     *
     * @param ConfigInterface $config Project configuration
     * @return string Namespace for generated code
     */
    private function buildNamespaceConfiguration(ConfigInterface $config): string
    {
        $namespace = trim($config->getNamespace(), '\\');
        
        // Ensure namespace follows PSR-4 conventions
        return str_replace('/', '\\', $namespace);
    }
}